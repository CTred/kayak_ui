# Creating a Widget

With Kayak UI you can create widgets using two different methods: using the widget proc macro or by manually
implementing `Widget` on a struct.

## Functional Widgets

This is by far the simplest method. It abstracts a lot of the boilerplate that the manual method requires, but
introduces possible complications with Rust's borrow checker and passing along props. Don't worry, in the future this
should get better!

Here is a simple example of creating your own widget:

```rust,noplayground
#[derive(WidgetProps, Debug, Default, Clone, PartialEq)]
struct MyWidgetProps {
  some_value: i32,
	#[prop_field(Children)]
	children: Option<Children>
}

#[widget]
pub fn MyWidget(props: MyWidgetProps) {
	println!("Contains Value: {}", props.some_value);
  let children = props.children.clone();
	rsx! {
		<>
			{children}
		</>
	}
}
```

> The empty tags (`<>` and `</>`) are shorthand for the built-in `Fragment` widget

In this example, we have created a widget named `MyWidget` that accepts the `MyWidgetProps` struct. This struct contains a `children` prop (for details on this prop check out the [Common Props](./common_props.md) section) and a `some_value` prop. And ultimately, it just passes its children without doing much else.

Notice that the contents of the `rsx` macro are not returned. The `widget` macro takes the content of this function and
adds code to the beginning and end of it. Returning after the `rsx!` will cause the render to exit early, which is generally not desired.

### Props

As discussed in the section on [creating props](./creating_props.md), you'll need to define a struct that contains all expected props for your widget. The name of your props (both the struct and the argument) doesn't matter. If you choose to not supply any props (your function has zero arguments), then it's automatically given props of type `()`, meaning this widget takes no props.

#### Mutability

Props are mutable. All changes applied to the props variable (and only that variable) are saved to the widget. Generally, you should only use this for common props, such as `styles` and `on_event`. However, it's recommended you instead don't mutate props at all (if you can help it). The alternative would be to apply your mutations to props passed on to a child widget.

For example, you can turn this:

```rust,noplayground
#[derive(WidgetProps, Debug, Default, Clone, PartialEq)]
struct MyWidgetProps {
  /// Private event handler, only settable within this module
  #[prop_field(OnEvent)]
  on_event: Option<OnEvent>
}

#[widget]
pub fn MyWidget(props: MyWidgetProps) {
  props.on_event = Some(OnEvent::new(/* ... */));
}
```

Into this:

```rust,noplayground
#[widget]
pub fn MyWidget() {
  let on_event = Some(OnEvent::new(/* ... */));
  
  rsx! {
    <Element on_event={on_event} />
  }
}
```

So instead of having the widget itself handle the event, the child element will be the one to take care of it. This also helps prevent overriding props specified by a parent. However, you may need to make sure the child widget takes up the same space as the widget itself (otherwise it might miss events or have odd styling).

### Hidden Code

There's a secret hidden from you by the `#[widget]` macro— the details of which will be explained in the next section. But this secret allows you to access seemingly non-existent code, and may even lead to confusing errors if you're not careful. Note that this may change in the future to allow for a simpler API.

#### Context

The most important of these is the `context` variable. This hidden variable provides access to the
containing `KayakContextRef`.

```rust,noplayground
#[widget]
pub fn MyWidget() {

	// We didn't define a `context` variable, but it's still accessible
	let state = context.create_state("foo".to_string());

	// ...
}
```

#### Shadowing Props

One important thing to understand is that the `#[widget]` macro gives you a *clone* of your props— and any changes to this variable are collected at the *end* of the function. This means you *cannot* shadow your props type if you wish for its changes to be saved.

```rust,noplayground
# #[derive(WidgetProps, Debug, Default, Clone, PartialEq)]
# struct MyWidgetProps {
#   some_value: i32,
# 	#[prop_field(Children)]
# 	children: Option<Children>
# }
# 
// Good
#[widget]
pub fn MyWidget(my_props: MyWidgetProps) {
	my_props.styles = Some(Style::default());
}

// Bad
#[widget]
pub fn MyWidget(my_props: MyWidgetProps) {
	my_props.styles = Some(Style::default());
	// ...
	let my_props = 123;
}
```

By shadowing `my_props`, we essentially lose the change to `my_props.styles`. Again, it might be more advisable to not change props directly, but be aware of this in case you do.

#### Self

In addition to `context`, you also have access to `self`, providing access to the underlying struct generated by the `widget` macro.

> Be careful when using `self`. While it is a mutable reference to the widget, it should generally not be used to update any of the widget's fields. Doing so may result in undefined behavior.
>
> It's best to use `self` when you need immutable access to a field, such as the ID of the widget. Even then, you may run into issues with Rust's borrow checker.

```rust,noplayground
#[widget]
pub fn MyWidget() {

	let id = self.id;
	
	// ...
}
```

## Manually Implementing `Widget`

You might be wondering: *Why does the `widget` macro work? What boilerplate is it actually hiding from us? Is there a way to create a widget manually if we really want to?*

To answer this, we'll recreate a simple widget, the `Element` widget.

First we define the widget's props:

```rust,noplayground
#[derive(WidgetProps, Default, Debug, PartialEq, Clone)]
pub struct ElementProps {
  #[prop_field(Styles)]
  pub styles: Option<Style>,
  #[prop_field(Children)]
  pub children: Option<Children>,
  #[prop_field(OnEvent)]
  pub on_event: Option<OnEvent>,
  #[prop_field(Focusable)]
  pub focusable: Option<bool>,
}
```

Next, we define the widget struct itself:

```rust,noplayground
#[derivative(Default, Debug, PartialEq, Clone)]
pub struct Element {
  pub id: Index,
  pub props: ElementProps,
}
```

Great! The last thing to do is actually implement `Widget`. This is done simply by:

```rust
impl kayak_core::Widget for Element {
  // Define the type of our props
  type Props = ElementProps;
  
  fn constructor(props: Self::Props) -> Self where Self: Sized {
      // We can do optional initialization here
    
      Self {
          id: Index::default(),
          props: props,
      }
  }
  
  fn get_id(&self) -> Index {
      self.id
  }
  
  fn set_id(&mut self, id: Index) {
      self.id = id;
  }
  
  fn get_props(&self) -> &Self::Props {
      &self.props
  }
  
  fn get_props_mut(&mut self) -> &mut Self::Props {
      &mut self.props
  }
  
  fn render(&mut self, context: &mut KayakContextRef) {
    
    // Update our styles
    let mut props = self.props.clone();
    props.styles = Some(Style {
      render_command: StyleProp::Value(RenderCommand::Layout),
      ..props.styles.clone().unwrap_or_default()
    });
    
    // Creates a new fragment widget to render the children
    let mut fragment_props = FragmentProps::default();
    fragment_props.set_children(self.props.get_children());
    let fragment = <Fragment as Widget>::constructor(fragment_props);
    
    // Adds the fragment widget to the widget tree
    context.add_widget(built_widget, 0usize);
    
    // Updates props to match any changes
    self.props = props;
    
    // Commits the sub tree to the main tree
    context.commit();
  }
  
}
```

Done! If we run `cargo expand` on the `Element` widget, we see that we actually got pretty close to the generated output:

```rust,noplayground
#[derivative(Default, Debug, PartialEq, Clone)]
pub struct Element {
  pub id: Index,
  pub props: ElementProps,
}

impl Widget for Element {
  type Props = ElementProps;
  
  fn constructor(props: Self::Props) -> Self where Self: Sized {
      Self {
          id: Index::default(),
          props: props,
      }
  }
  fn get_id(&self) -> Index {
      self.id
  }
  fn set_id(&mut self, id: Index) {
      self.id = id;
  }
  fn get_props(&self) -> &Self::Props {
      &self.props
  }
  fn get_props_mut(&mut self) -> &mut Self::Props {
      &mut self.props
  }
  
  fn render(&mut self, context: &mut KayakContextRef) {
    use kayak_core::WidgetProps;
    let parent_id = Some(self.get_id());
    let children = self.props.get_children();
    let mut props = self.props.clone();
    
    // This block is actually where the code from a functional widget is placed
    {
    
      // Update our styles
      props.styles = Some(Style {
        render_command: StyleProp::Value(RenderCommand::Layout),
        ..props.styles.clone().unwrap_or_default()
      });
      
      {
          // Creates a new fragment widget which renders the children
          let mut internal_rsx_props = <Fragment as Widget>::Props::default();
          let children = children.clone();
          WidgetProps::set_children(
              &mut internal_rsx_props,
              children.clone(),
          );
          let built_widget = <Fragment as Widget>::constructor(internal_rsx_props);
          
          // Adds the fragment widget to the widget tree
          context.add_widget(built_widget, 0usize);
      }
    }
    
    // Updates props to match any changes
    self.props = props;
    
    // Commits the sub tree to the main tree
    context.commit();
  }
}
```

As you can see, we really only need to implement `Widget` for a struct to actually be considered a widget.

However, the trouble with this comes from the `render` method. This method contains a lot of code that should exist on almost every widget, such as setting the current ID and diffing/merging tree. This is why the functional widget approach is generally preferred. However, doing this allows for finer control over the widget, its props, and how it's rendered.

