# Creating a Widget

With Kayak UI you can create widgets using two different methods: using the widget proc macro or by manually
implementing `Widget` on a struct.

## Functional Widgets

This is by far the simplest method. It abstracts a lot of the boilerplate that the manual method requires, but
introduces possible complications with Rust's borrow checker and passing along props. Don't worry, in the future this
should get better!

Here is a simple example of creating your own widget:

```rust,noplayground
#[widget]
pub fn MyWidget(children: Children) {
	rsx! {
		<>
			{children}
		</>
	}
}
```

> The empty tags (`<>` and `</>`) are shorthand for the built-in `Fragment` widget

In this example, we have created a widget named `MyWidget` that accepts a `children` prop (for details on this prop
check out the [Common Props](./common_props.md) section). It simply passes its children without doing much else.

Notice that the contents of the `rsx` macro are not returned. The `widget` macro takes the content of this function and
adds code to the beginning and end of it. Returning after the `rsx!` will cause the render to exit early, which is
generally not desired.

### Hidden Code

There's a secret hidden from you by the `widget` macroâ€” the details of which will be explained in the next section. But
this secret allows you to access seemingly non-existent code, and may even lead to confusing errors if you're not
careful. Note that this may change in the future to allow for a simpler API (
see [RFC 1](https://github.com/StarArawn/kayak_ui/blob/book/rfcs/widget-restructure-rfc-1.md)).

#### Context

The most important of these is the `context` variable. This hidden variable provides access to the
containing `KayakContext`.

```rust,noplayground
#[widget]
pub fn MyWidget() {

	// We didn't define a `context` variable, but it's still accessible
	let state = context.create_state("foo".to_string());

	// ...
}
```

#### Self

In addition to `context`, you also have access to `self`, providing access to the underlying struct generated by
the `widget` macro.

> Be careful when using `self`. While it is a mutable reference to the widget, it should generally not be used to update any of the widget's fields (except for maybe `styles`). Doing so may result in undefined behavior.
>
> It's best to use `self` when you need immutable access to a field, such as the ID of the widget. Even then, you may run into issues with Rust's borrow checker.

```rust,noplayground
#[widget]
pub fn MyWidget() {

	let id = self.id;
	
	// ...
}
```

#### Styles

Lastly, you are also given direct access to one of the common props: `styles`. This allows you to more elegantly edit
your widget's style, without having to write `self.styles` or `let styles = self.styles`.

```rust,noplayground
#[widget]
pub fn MyWidget() {

	*styles = Some(Style {
		padding_left: StyleProp::Value(Units::Pixels(12.0)),
		..styles.clone().unwrap_or_default() // Maintain parent-defined styles
	});
	
	// ...
}
```

## Manually Implementing `Widget`

You might be wondering: *Why does the `widget` macro work?* *What boilerplate is it actually hiding from us?* I*s there
a way to create a widget manually if we really want to?*

To answer this we'll break down a functional widget and see what it generates. By running `cargo expand` on
the `Element` widget:

```rust,noplayground
#[widget]
pub fn Element(children: Children) {
    *styles = Some(Style {
        render_command: StyleProp::Value(RenderCommand::Layout),
        ..styles.clone().unwrap_or_default()
    });

    rsx! {
        <>
            {children}
        </>
    }
}
```

we end up with the generated output:

```rust,noplayground
#[derivative(Default, Debug, PartialEq, Clone)]
pub struct Element {
    pub id: kayak_core::Index,
    #[derivative(Debug = "ignore", PartialEq = "ignore")]
    pub children: Children,
    #[derivative(Default(value = "None"))]
    pub styles: Option<kayak_core::styles::Style>,
    #[derivative(Default(value = "None"), Debug = "ignore", PartialEq = "ignore")]
    pub on_event: Option<kayak_core::OnEvent>,
    #[derivative(Default(value = "None"))]
    pub focusable: Option<bool>,
}

 impl kayak_core::Widget for Element {
    fn get_id(&self) -> kayak_core::Index {
        self.id
    }
    fn focusable(&self) -> Option<bool> {
        self.focusable
    }
    fn set_id(&mut self, id: kayak_core::Index) {
        self.id = id;
    }
    fn get_styles(&self) -> Option<kayak_core::styles::Style> {
        self.styles.clone()
    }
    fn get_name(&self) -> String {
        String::from("Element")
    }
    fn on_event(
        &mut self,
        context: &mut kayak_core::context::KayakContext,
        event: &mut kayak_core::Event,
    ) {
        if let Some(on_event) = self.on_event.as_ref() {
            if let Ok(mut on_event) = on_event.0.write() {
                on_event(context, event);
            }
        }
    }
    fn render(&mut self, context: &mut kayak_core::context::KayakContext) {
        // It's important to set the current ID this is how we track state management.
        let parent_id = self.get_id();
        context.set_current_id(parent_id);
        let parent_id = Some(parent_id);

        // We pull out the props(struct fields) from the widget here.
        let Element {
            children, ..
        } = self;

        let children = children.clone();

        // We create a new sub tree.
        let tree = kayak_core::WidgetTree::new();
        
        // This block is actually where the code from a functional widget is placed
        {
            // Creates a new fragment widget which renders the children. 
            let built_widget = ::kayak_core::Fragment {
                children: children.clone(),
                styles: None,
                on_event: None,
                ..Default::default()
            };

            // Creates the fragment widget.
            let (should_rerender, child_id) =
                context
                    .widget_manager
                    .create_widget(0usize, built_widget, parent_id);
            // Add the fragment widget to the sub tree.
            tree.add(child_id, parent_id);
            
            // If should_rerender is true we need to render the widget.
            if should_rerender {
                // We pull the widget out of storage
                let mut child_widget = context.widget_manager.take(child_id);
                // Render the widget
                child_widget.render(context);
                // And place it back into storage.
                context.widget_manager.repossess(child_widget);
            }
        }
        
        // Take ownership of the sub tree.
        let tree = tree.take();

        // Diff the sub tree with the full UI tree.
        let changes = context
            .widget_manager
            .tree
            .diff_children(&tree, self.get_id());

        // Apply the changes to the full UI tree.
        context
            .widget_manager
            .tree
            .merge(&tree, self.get_id(), changes);
    }
}
```

As you can see, we really only need to implement `Widget` for a struct to actually be considered a widget.

However, the trouble with this comes from the `render` method. This method contains a lot of code that should exist
on almost every widget, such as setting the current ID and diffing/merging the tree. This is why the functional widget
approach is generally preferred. However, doing this allows for finer control over the widget, its props, and how it's
rendered.

And actually, a lot of the complexity here is to be replaced by a simpler system (please
see: [RFC 1](https://github.com/StarArawn/kayak_ui/blob/book/rfcs/widget-restructure-rfc-1.md)). This will allow people
to make struct-based widgets in a much more user-friendly way.

